{"version":3,"sources":["edamame/core.cljc"],"mappings":";AAWA,AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,AAAAA,AAAME;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMD,AAgDFE;AAhDJ,AAiDG,AAAA,AAACC,AAAeD;;;AAjDnB,AAAA,AAAA,AAAMF,AAkDFE,AAAEE;AAlDN,AAmDG,AAACD,AAAeD,AAAEE;;;AAnDrB,AAAA,AAAA,AAAMJ;;AAAN,AAqDA,AAAA;;;;AAAA,AAAAF,AAAMQ;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAL,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMK,AAGFJ;AAHJ,AAIG,AAAA,AAACK,AAAmBL;;;AAJvB,AAAA,AAAA,AAAMI,AAKFJ,AAAEE;AALN,AAMG,AAACG,AAAmBL,AAAEE;;;AANzB,AAAA,AAAA,AAAME;;AAAN,AAUA","names":["var_args","G__46519","edamame.core/parse-string","js/Error","s","edamame.impl.parser/parse-string","opts","G__46527","edamame.core/parse-string-all","edamame.impl.parser/parse-string-all"],"sourcesContent":["(ns edamame.core\n  (:require\n   [edamame.impl.parser :as p]))\n\n;; undocumented, still alpha, only used by @kwrooijen at the moment:\n;; `:postprocess`: a function that will be called with a map containing\n;; `:obj`, the read value, and `:loc`, the location metadata. This can\n;; be used to handle objects that cannot carry metadata differently. If\n;; this option is provided, attaching location metadata is not\n;; automatically added to the object.\n\n(defn parse-string\n  \"Parses first EDN value from string.\n\n  Supported parsing options:\n\n  `:deref`: parse forms starting with `@`. If `true`, the resulting\n  expression will be parsed as `(deref expr)`.\n\n  `:fn`: parse function literals (`#(inc %)`). If `true`, will be parsed as `(fn [%1] (inc %))`.\n\n  `:quote`: parse quoted expression `'foo`. If `true`, will be parsed as `(quote foo)`.\n\n  `:read-eval`: parse read-eval (`=(+ 1 2 3)`). If `true`, the\n  resulting expression will be parsed as `(read-eval (+ 1 2 3))`.\n\n  `:regex`: parse regex literals (`#\\\"foo\\\"`). If `true`, defaults to\n  `re-pattern`.\n\n  `:syntax-quote`: parse syntax-quote (`(+ 1 2 3)`). Symbols get\n  qualified using `:resolve-symbol` which defaults to `identity`:\n  `(parse-string \\\"`x\\\" {:syntax-quote {:resolve-symbol #(symbol \\\"user\\\" (str %))}})\n  ;;=> (quote user/x)`.\n\n  `:var`: parse var literals (`#'foo`). If `true`, the resulting\n  expression will be parsed as `(var foo)`.\n\n  `:all`: when `true`, the above options will be set to `true` unless\n  explicitly provided.\n\n  Supported options for processing reader conditionals:\n\n  `:read-cond`: - `:allow` to process reader conditionals, or\n                  `:preserve` to keep all branches\n  `:features`: - persistent set of feature keywords for reader conditionals (e.g. `#{:clj}`).\n\n  `:auto-resolve`: map of alias to namespace symbols for\n  auto-resolving keywords. Use `:current` as the alias for the current\n  namespace.\n\n  `:readers`: data readers.\n\n  Additional arguments to tools.reader may be passed with\n  `:tools.reader/opts`, like `:readers` for passing reader tag functions.\n\n  Deprecated options:\n\n  `:dispatch`: DEPRECATED by parsing options.\n  \"\n  ([s]\n   (p/parse-string s nil))\n  ([s opts]\n   (p/parse-string s opts)))\n\n(defn parse-string-all\n  \"Like parse-string but parses all values from string and returns them\n  in a vector.\"\n  ([s]\n   (p/parse-string-all s nil))\n  ([s opts]\n   (p/parse-string-all s opts)))\n\n;;;; Scratch\n\n(comment\n  (parse-string \"(1 2 3 #_4)\"))\n"]}